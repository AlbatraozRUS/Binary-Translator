///////////////////////////////////////////////////////////////////////////////
// Macros "instruction" has 3 fields: 
// 1) <name>     - name of instruction to compare
// 2) <ID>       - id of instruction (used in enum INSTRUCTIONS in CPU-Simulator.h)
// 3) <ARGTYPES> - types of arguments of instruction. 
//    NOARG = 0      - without arguments
//    LABEL = 1      - with a label for jump 
//    NUMBER = 2     - argument is a number
//    REG = 3        - argument is a register
//    REG_REG = 4    - two registers are arguments
//    REG_NUMBER = 5 - two arguments, first one is register, other is a number
///////////////////////////////////////////////////////////////////////////////


#ifdef INSTRUCTIONS
INSTRUCTION(PUSH, 0, 2, 
    stack_.push(bytecode_[PC + 1]);
    PC += 2;)
INSTRUCTION(PUSH_R, 1, 3,
    stack_.push(registers_[bytecode_[PC + 1]]);
    PC += 2;)
INSTRUCTION(POP_R, 2, 3,
    registers_[bytecode_[PC + 1]] = stack_.top();
    stack_.pop();
    PC += 2;)
INSTRUCTION(MOV, 3, 5,
    registers_[bytecode_[PC + 2]] = bytecode_[PC + 1];
    PC += 3;)
INSTRUCTION(MOV_R, 4, 4, 
    registers_[bytecode_[PC + 2]] = registers_[bytecode_[PC + 1]];
    PC += 3;)
INSTRUCTION(CALL, 5, 1, 
    callerStack_.push(PC + 2); 
    PC += bytecode_[PC + 1];)
INSTRUCTION(RET, 6, 0, 
    PC = callerStack_.top();
    callerStack_.pop();)
INSTRUCTION(EXIT,   7, 0, 
    return;)
INSTRUCTION(WRITE, 8, 3, 
    std::cout << registers_[bytecode_[PC + 1]] << "\n";
    PC += 2;)
INSTRUCTION(READ, 9, 3,
     std::cin >> registers_[bytecode_[PC + 1]];
     PC += 2;)

INSTRUCTION(ADD_R, 10, 4, 
    registers_[bytecode_[PC + 2]] += registers_[bytecode_[PC + 1]];
    PC += 3;)
INSTRUCTION(SUB_R, 11, 4, 
    registers_[bytecode_[PC + 2]] -= registers_[bytecode_[PC + 1]];
    PC += 3;)
INSTRUCTION(MUL_R, 12, 4, 
    registers_[bytecode_[PC + 2]] *= registers_[bytecode_[PC + 1]];
    PC += 3;)
INSTRUCTION(DIV_R, 13, 4, 
    registers_[bytecode_[PC + 2]] /= registers_[bytecode_[PC + 1]];
    PC += 3;)
INSTRUCTION(ADD, 14, 5, 
    registers_[bytecode_[PC + 2]] += bytecode_[PC + 1];
    PC += 3;)
INSTRUCTION(SUB, 15, 5, 
    registers_[bytecode_[PC + 2]] -= bytecode_[PC + 1];
    PC += 3;)
INSTRUCTION(MUL, 16, 5, 
    registers_[bytecode_[PC + 2]] *= bytecode_[PC + 1];
    PC += 3;)
INSTRUCTION(DIV, 17, 5, 
    registers_[bytecode_[PC + 2]] /= bytecode_[PC + 1];
    PC += 3;)
INSTRUCTION(INC, 18, 3, 
    registers_[bytecode_[PC + 1]]++;
    PC += 2;)
INSTRUCTION(DEC, 19, 3, 
    registers_[bytecode_[PC + 1]]--;
    PC += 2;)

INSTRUCTION(CMP, 20, 5, 
    isFlag = registers_[bytecode_[PC + 2]] - registers_[bytecode_[PC + 1]];
    PC += 3;)
INSTRUCTION(CMP_R, 21, 4, 
    isFlag = registers_[bytecode_[PC + 2]] - bytecode_[PC + 1];
    PC += 3;)
INSTRUCTION(JMP, 22, 1, 
    PC += bytecode_[PC + 1];)
INSTRUCTION(JA, 23, 1, 
    if (isFlag > 0) 
        PC += bytecode_[PC + 1];
    else 
        PC += 2;)
INSTRUCTION(JAE, 24, 1, 
    if (isFlag >= 0) 
        PC += bytecode_[PC + 1];
    else
        PC += 2;)
INSTRUCTION(JB, 25, 1, 
    if (isFlag < 0) 
        PC += bytecode_[PC + 1];
    else
        PC += 2;)
INSTRUCTION(JBE, 26, 1, 
    if (isFlag <= 0) 
        PC += bytecode_[PC + 1];
    else    
        PC += 2;)
INSTRUCTION(JE, 27, 1, 
    if (isFlag == 0) 
        PC += bytecode_[PC + 1];
    else
        PC += 2;)
INSTRUCTION(JNE, 28, 1, 
    if (isFlag != 0) 
        PC += bytecode_[PC + 1];
    else
        PC += 2;)

#endif